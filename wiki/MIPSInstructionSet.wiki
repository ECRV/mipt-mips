#summary MIPS Instruction Set

= Instruction format =

MIPS is a RISC processor, so every instruction has the same length — 32 bits (4 bytes). These bits have different meanings according to their displacement. They can be combined in following groups:

|| *Name* || *Size* || *Symbol* || *Used for* ||
|| Opcode || 6 bits || `E` || Specification of instruction ||
|| Register specifications || 5 bits || `s`,`t`,`d` || _see below_ ||
|| Shamt || 5 bit || `S` || Constant value for shifts ||
|| Immediate constant value || 16 bit || `C` || Immediate value for AL operations ||
|| Address || 26 bit || `A` || Address for jumps and procedure calls ||
|| Funct || 6 bit || `f` || Second part of opcode. Usually it is used for more precise specification of instruction (addition/subtraction, signed/unsigned etc.) ||

|| <font color="red"><b>Note!</b></font> Even 26-bit field is called Address, it is not used for loads and stores! ||
|| <font color="red"><b>Note!</b></font> GoogleCode wiki has font without crossed zero, so we will use 'E' instead of more common 'O' for opcode. ||

== Register specificators ==

Register specificators are addresses of registers. They are used to show, which registers have source data and where machine should write result of instruction. MIPS supports instructions with up to 3 registers. They are named:

  * s-register _(source)_
  * t-register _(target)_
  * d-register _(destination)_

|| <font color="red"><b>Note!</b></font> s- and t- registers *do not* correspond to
s0-s7 and t0-t7 registers described on [MIPSRegisters MIPS Registers page]. Here it is just notation. ||

Address of register consists of 5 bits, so there can be 32 usable logical registers on one core.

=== Zero register ===

MIPS has a special joker register called $zero. Its address is 00000, and value is always zero. Programmer is free to use it with reading, but can not write in it.

== Types of format ==

MIPS supports 3 main types of instruction format: R, I and J.

|| *Type name* || *Max amount of registers* || *Instruction bits* || *Used for* ||
|| R || 3 || `EEEEEEss sssttttt dddddSSS SSffffff` || AL and shift operations on registers ||
|| I || 2 || `EEEEEEss sssttttt CCCCCCCC CCCCCCCC` || AL operations with immediate values, load/stores||
|| J || 0 || `EEEEEEAA AAAAAAAA AAAAAAAA AAAAAAAA` || Unconditional branches, procedure calls||


= Instructions Table =

== Legend format ==
 * `0|1` — plain bit values
 * `-` — ignored values

|| <font color="red"><b>Note!</b></font> All plain numbers in this and following paragraphs are hexadecimal! ||


|| *Name* || *Assembly syntax* || *Operation in C* || *Type* || *Opcode/Funct* ||*Full format* ||
|| *Add/subtract* ||
|| add || `add $d, $s, $t` ||  `d = t + s` || R || 0 / 20 || `000000ss sssttttt ddddd--- --100000` ||
|| add unsigned || `addu $d, $s, $t` ||  `d = t + s` || R || 0 / 21 || `000000ss sssttttt ddddd--- --100001` ||
|| substract || `sub $d, $s, $t` || `d = t - s` || R || 0 / 22 || `000000ss sssttttt ddddd--- --100010` ||
|| substract unsigned || `subu $d, $s, $t` || `d = t - s` || R || 0 / 23 || `000000ss sssttttt ddddd--- --100011` ||
|| add immediate || `addi $t, $s, C` || `t = s + C` || I || 8 || `001000ss sssttttt CCCCCCCC CCCCCCCC` ||
|| add immediate unsigned || `addiu $t, $s, C` || `t = s + C` || I || 9 || `001001ss sssttttt CCCCCCCC CCCCCCCC` ||
|| *Shifts* ||
|| *Name* || *Assembly syntax* || *Operation in C* || *Type* || *Opcode/Funct* ||*Full format* ||
|| shift left logical || `sll $d, $t, C` || `d = t << S` || R || 0 / 0 || `000000-- ---ttttt dddddSSS SS000000` ||
|| shift right logical || `srl $d, $t, C` || `d = t >> S` || R || 0 / 2 || `000000-- ---ttttt dddddSSS SS000010` ||
|| *Conditional branches* ||
|| branch on equal || `beq $s, $t, C` || `if (s == t) goto PC + 4 + 4 * C` || I || 4 || `000100ss sssttttt CCCCCCCC CCCCCCCC` ||
|| branch on not equal || `bne $s, $t, C` || `if (s != t) goto PC + 4 + 4 * C` || I || 5 || `000101ss sssttttt CCCCCCCC CCCCCCCC` ||
|| *Unconditional jump* ||
|| jump || `j C` || `goto PC + 4 + С*4` || J || 2 || `000010AA AAAAAAAA AAAAAAAA AAAAAAAA` ||
|| jump register || `jr $s` || `goto [s]` || R || 0 / 8 || `000000ss sss----- -------- --000100` ||

= Pseudo-instructions =

Some operations without separate instruction can be performed with help of other instructions. 

|| *Name* || *Assembly syntax* || *Expansion* || *Operation in C* || *Opcode and format* ||
|| move || `move $t, $s` || `addiu $t, $s, 0` || t = s || `001001ss sssttttt 00000000 00000000` || 
|| clear || `clear $t` || `addu $t, $zero, $zero` || t = 0 || `00000000 000ttttt 00000--- --100001` ||
|| nop || `nop` || `sll $zero, $zero, 0` || || `00000000 00000000 00000000 00000000` ||